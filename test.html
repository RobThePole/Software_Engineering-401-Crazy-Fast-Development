<html>
<head>
  <script type="text/javascript" src="External JS/jquery-3.2.1.js"></script>
  <script type="text/javascript" src="External JS/fabric.min.js"></script>
  <script type="text/javascript" src="External JS/fileSaver.js"></script>

  
</head>
<body>
<canvas id="c" width="800" height="600"></canvas>
<input id="b" type="button" value="Save as Image" />
<script>

const canvas = new fabric.Canvas("c", {stateful: true})


fabric.RotatingLine = fabric.util.createClass(fabric.Line, {
  minLength: 50, // we need to set this thing in px now
  
  initialize: function (points, options) {
    const a = new fabric.Point(points[0], points[1])
    const b = new fabric.Point(points[2], points[3])
    // find this line's vector
    const vectorB = b.subtract(a)
    // find angle between line's vector and x axis
    let angleRad = Math.atan2(vectorB.y, vectorB.x)
    if (angleRad < 0) {
      angleRad = 2 * Math.PI + angleRad
    }
    const angleDeg = fabric.util.radiansToDegrees(angleRad)
    // find initial horizontal position by rotating the tip back
    const c = fabric.util.rotatePoint(b.clone(), a, -angleRad)
    options = options || {}
    // finally, initialize using transform points to make a horizontal line
    this.callSuper('initialize', [a.x, a.y, c.x, c.y], {
      noScaleCache: false, // false to force cache update while scaling (doesn't redraw parts of line otherwise)
      selectable: true,
      evented: true, // true because you want to select line on click
      //minScaleLimit: 0.25, // has no effect now because we're resetting scale on each scale event
      lockRotation: false,
      hasRotatingPoint: false, // to disable rotation control
      centeredRotation: false,
      centeredScaling: false,
      
      originX: "left",    // origin of rotation/transformation.      
      originY: "bottom",    // origin of rotation/transformation.
      
      //lockMovementX: true,
      //lockMovementY: true,
      lockScalingFlip: true,
      lockScalingX: false,
      lockScalingY: false,
      lockSkewingX: false,
      lockSkewingY: false,
      lockUniScaling: true,
      ...options,
      angle: angleDeg // note that we use the calculated angle no matter what
    })
    
    this.setControlsVisibility({
        tr: false,
        tl: false,
        mt: true, // middle top disable
        mb: false, // midle bottom
        ml: false, // middle left
        mr: false, // I think you get it
    })
    
    this.on('scaling', function (e) {
	  // rotate to the pointer's x,y

	  console.log(e.transform.corner);
	  if(e.transform.corner == "bl")
	  {
		
		this.canvas._rotateObject(e.pointer.x, e.pointer.y)
		this.set({left: this.x1, top: this.y1})

		const xOffset = (this.x2 - this.x1) * this.scaleX
      const newLength = Math.max(this.minLength, xOffset)

		this.set({
        scaleX: 1,
		scaleY: 1,
		x1: this.x2 + newLength
      })



	  }
	  else if ( e.transform.corner == "br")
	  {
		this.canvas._rotateObject(e.pointer.x, e.pointer.y)
      // while _rotateObject() tries to keep left/top at initial value,
      // it sometimes fails because of rounding errors (?)
      // so we need to do it manually again
      this.set({left: this.x1, top: this.y1})
      // calculate new length before resetting scale
      const xOffset = (this.x2 - this.x1) * this.scaleX
      const newLength = Math.max(this.minLength, xOffset)
      // reset scaleX/scaleY and set new x coord for the tip point
      this.set({
        scaleX: 1,
        scaleY: 1,
        x2: this.x1 + newLength
      })

	  }

    })
  }
})

													   // Last value is the rotating point
const line1 = new fabric.RotatingLine([ 200, 250, 330, 200 ], {
  fill: 'red',
  stroke: 'red',
  strokeWidth: 3,
});



canvas.add(line1)

// Disables group selection.
canvas.on('selection:created', (e) => {
  if(e.target.type === 'activeSelection') {
    canvas.discardActiveObject();
  } else {
    //do nothing
  }
})

// Keeps objects inside canvas. undos move/rotate/scale out of canvas.
canvas.on('object:modified', function (options) {
    let obj = options.target;
    let boundingRect = obj.getBoundingRect(true);
    if (boundingRect.left < 0
        || boundingRect.top < 0
        || boundingRect.left + boundingRect.width > canvas.getWidth()
        || boundingRect.top + boundingRect.height > canvas.getHeight()) {
        obj.top = obj._stateProperties.top;
        obj.left = obj._stateProperties.left;
        obj.angle = obj._stateProperties.angle;
        obj.scaleX = obj._stateProperties.scaleX;
        obj.scaleY = obj._stateProperties.scaleY;
        obj.setCoords();
        obj.saveState();
    }
});
</script>

</body>
</html>